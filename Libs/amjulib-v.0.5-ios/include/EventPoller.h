#ifndef AMJU_EVENT_POLLER_H_INCLUDED
#define AMJU_EVENT_POLLER_H_INCLUDED

#include <queue>
#include "EventListener.h"
#include "RCPtr.h"
#include <Singleton.h>

namespace Amju
{
class EventPollerImpl : public RefCounted
{
public:
  virtual ~EventPollerImpl() {}

  // Overrides call this impl
  virtual void Update(Listeners* pListeners);

  // Queue a new event - this can be used from e.g. GLUT callbacks; or new events could
  //  be generated by event handlers, e.g. a soft keyboard could generate key events.
  void QueueEvent(Event*); // event on heap, deleted in Update()

private:
  typedef std::queue<Event*> EventQueue;
  EventQueue m_q;

protected:
  // Notify all listeners of the event until the event is handled
  //  and only lower priority listeners have not been notified.
  void NotifyListenersWithPriority(Event* evemt, Listeners* pListeners);
};

// "Generic" behaviour allowing events to be queued is now in the base class.
// All poller impls should work by queueing events.
class EventPollerImplGeneric : public EventPollerImpl 
{
};

typedef RCPtr<EventPollerImpl> PEventPollerImpl;

enum { AMJU_MIN_PRIORITY = -999, AMJU_MAX_PRIORITY = 999 };

class EventPoller : public NonCopyable
{
public:
  // Listeners have a priority. They are notified in ascending order.
  // If a listener eats the event, listeners with a lower priority are not notified.
  void AddListener(EventListener*, int priority = 0);

  // Add special listeners (cursors) which always get events but never consume them
  void AddCursorListener(EventListener*);

  void RemoveListener(EventListener*);
  bool HasListener(EventListener*) const;
  void SetListenerPriority(EventListener*, int priority);

  // Set a listener which will be the only listener to receive events, until this 
  //  is cancelled by calling with nullptr as parameter
  void SetModalListener(EventListener*);

  void Clear();

  void SetImpl(EventPollerImpl*);
  EventPollerImpl* GetImpl();

  void Update();
  
  // Transform for cursor events, so the range (-1..1) is not mapped to the entire
  //  screen width and height.
  void SetCursorTransform(float scaleX, float scaleY, float translateX, float translateY);

private:
  PEventPollerImpl m_pImpl;
  Listeners m_listeners;
  Listeners m_cursors;

  // If non zero, this is the only listener to receive events,
  //  except for cursors, which always get them.
  RCPtr<EventListener> m_modalListener;
};

typedef SingletonNoDestroy<EventPoller> TheEventPoller;
}

#endif // AMJU_EVENT_POLLER_H_INCLUDED

